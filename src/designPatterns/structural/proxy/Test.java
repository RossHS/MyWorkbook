package designPatterns.structural.proxy;

import java.rmi.Naming;

/**
 * Заместитель — это структурный паттерн проектирования, который позволяет подставлять
 * вместо реальных объектов специальные объекты-заменители. Эти объекты перехватывают
 * вызовы к оригинальному объекту, позволяя сделать что-то до или после передачи вызова оригиналу.
 * <p>
 * Ленивая инициализация (виртуальный прокси). Когда у вас есть тяжёлый объект, грузящий данные
 * из файловой системы или базы данных.
 * <p>
 * Вместо того, чтобы грузить данные сразу после старта программы, можно
 * сэкономить ресурсы и создать объект тогда, когда он действительно понадобится.
 * <p>
 * Защита доступа (защищающий прокси). Когда в программе есть разные типы пользователей,
 * и вам хочется защищать объект от неавторизованного доступа. Например, если ваши
 * объекты — это важная часть операционной системы, а пользователи — сторонние программы (хорошие или вредоносные).
 * <p>
 * Прокси может проверять доступ при каждом вызове и передавать выполнение служебному объекту, если доступ разрешён.
 * <p>
 * Локальный запуск сервиса (удалённый прокси). Когда настоящий сервисный объект находится на удалённом сервере.
 * <p>
 * В этом случае заместитель транслирует запросы клиента в вызовы по сети в протоколе, понятном удалённому сервису.
 * <p>
 * Логирование запросов (логирующий прокси). Когда требуется хранить историю обращений к сервисному объекту.
 * <p>
 * Заместитель может сохранять историю обращения клиента к сервисному объекту.
 * <p>
 * Кеширование объектов («умная» ссылка). Когда нужно кешировать результаты
 * запросов клиентов и управлять их жизненным циклом.
 * <p>
 * Заместитель может подсчитывать количество ссылок на сервисный объект, которые
 * были отданы клиенту и остаются активными. Когда все ссылки освобождаются,
 * можно будет освободить и сам сервисный объект (например, закрыть подключение к базе данных).
 * <p>
 * Кроме того, Заместитель может отслеживать, не менял ли клиент сервисный объект.
 * Это позволит использовать объекты повторно и здóрово экономить ресурсы, особенно
 * если речь идёт о больших прожорливых сервисах.
 *
 * @author Ross Khapilov
 * @version 1.0 26.06.2019
 */
public class Test {
    public static void main(String[] args) {
        new Test().generateReport();
    }

    public void generateReport() {
        try {
            ReportGenerator reportGenerator = (ReportGenerator) Naming.lookup("rmi://127.0.0.1/PizzaCoRemoteGenerator");
            System.out.println(reportGenerator.generateDailyReport());
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
