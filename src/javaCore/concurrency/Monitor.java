package javaCore.concurrency;

/**
 * Монитор - это класс, имеющий только приватные поля.
 * Каждый объект этого класса имеет ассоциированную с ним блокировку.
 * Все методы блокируются этой блокировкой. Другими словами, если клиент вызывает obj.method(), то при этом
 * автоматически запирается блокировка объекта obj в начале метода и освобождается по его завершении. Поскольку все
 * поля приватные, такой подход гарантирует, что ни один поток не сможет обратиться к ним, пока ими манипулирует
 * какой-то другой поток.
 * Блокировка может иметь любое количество ассоциированных условий.
 * Ранние версии монитора имели единственное условие, с достаточно элегантным синтаксисом. Вы можете просто вызвать
 * await accounts[from] >= balance, не используя явно условную переменную. Однако исследование показали,
 * что неразборчивая повторная проверка условий может оказаться неэффективной. Проблема была решена применением явных
 * переменных условий, каждая из которых управляет отдельным набором потоков.
 * <p>
 * Проектировщики Java вольно адаптировали концепцию монитора. Каждый объект в Java обладает внутренной блокировкой
 * и внутренним условием. Если метод объявлен с ключевым словом synchronized, он работает как метод монитора.
 * Переменная условия доступна через вызовы wait/notifyAll/notify.
 * <p>
 * Однако объекты Java отличаются от мониторов в трех важных отношениях, ослабляющих безопасность потоков.
 * <p>
 * Поля не обязательно должны быть private.
 * Методы не обязаны быть synchronized.
 *
 * @author Ross Khapilov
 * @version 1.0 10.09.2018
 */
public class Monitor {
}
