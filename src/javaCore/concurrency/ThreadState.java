package javaCore.concurrency;

/**
 * Потоки могут находиться в одном из шести состояний:
 * • новый;
 * • исполняемый;
 * • блокированный;
 * • ожидающий;
 * • временно ожидающий;
 * • завершенный.
 * <p>
 * Чтобы определить
 * текущее состояние потока исполнения, достаточно вызвать метод getState().
 *
 * @author Ross Khapilov
 * @version 1.0 03.09.2018
 */
public class ThreadState implements Runnable {

    /**
     * Если поток исполнения создан в результате операции new, например new
     * Thread(r), то он еще не запущен на выполнение. Это означает, что он находится
     * в новом состоянии и что программа еще не запустила на исполнение код в данном
     * потоке.
     *
     * @return состояние потока - NEW
     */
    private static Thread.State NEW() {
        Thread thread = new Thread(new ThreadState());
        return thread.getState();
    }

    /**
     * Как только вызывается метод start (), поток оказывается в исполняемом состоянии.
     * Исполняемый поток может выполняться или не выполняться в данный момент,
     * поскольку от операционной системы зависит, будет ли выделено потоку время на исполнение.
     * (Но в спецификации Java это отдельное состояние не указывается. Поток
     * по-прежнему находится в исполняемом состоянии.)
     *
     * @return состояние потока - RUNNABLE
     */
    private static Thread.State RUNNABLE() {
        Thread thread = new Thread(new ThreadState());
        thread.start();
        return thread.getState();
    }

    /**
     * Когда поток исполнения находится в состоянии блокировки или ожидания, он
     * временно не активен. Он не выполняет никакого кода и потребляет минимум ресурсов.
     * На планировщике потоков лежит обязанность повторно активизировать его.
     * Когда поток исполнения ожидает от другого потока уведомления планировщика
     * о наступлении некоторого условия, он входит в состояние ожидания. Переход в состояние ожидания
     * происходит при вызове метода Object.wait () или Thread, join () либо
     * в ожидании объекта типа Lock или Condition из библиотеки java.util.concurrent.
     * Несколько методов принимают в качестве параметра время ожидания. Их вызов
     * вводит поток исполнения в состояние временного ожидания. Это состояние сохраняется
     * до тех пор, пока не истечет заданное время ожидания или не будет получено
     * соответствующее уведомление. К числу методов со временем ожидания относятся
     * Object.wait(), Thread.join(), Lock.tryLock() и Condition.await().
     * состояние потока - WAITING
     */
    private static void WAITING() throws InterruptedException {

    }

    /**
     * Поток исполнения завершается по одной из следующих причин.
     * <p>
     * • Прекращает свое существование естественным образом при нормальном завершении
     * метода run().
     * • Прекращает свое существование внезапно, поскольку неперехваченное исключение
     * прерывает выполнение метода run().
     * <p>
     * В частности, поток исполнения можно уничтожить, вызвав его метод stop (). Этот
     * метод генерирует объект ошибки типа ThreadDeath, который уничтожает поток исполнения.
     * Но метод stop() не рекомендован к применению, поэтому следует избегать
     * его применения в прикладном коде.
     *
     * @return состояние потока - TERMINATED
     */
    private static Thread.State TERMINATED() throws InterruptedException {
        Thread thread = new Thread(new ThreadState());
        thread.start();
        Thread.sleep(1000);
        return thread.getState();
    }


    public static void main(String[] args) throws InterruptedException {
        System.out.println(NEW());
        System.out.println(RUNNABLE());
        WAITING();
        System.out.println(TERMINATED());
    }

    @Override
    public void run() {
        for (int i = 0; i < 5; i++) {
            System.out.print(Thread.currentThread().getName() + " " + i + " ");
        }
        System.out.println();
    }
}
