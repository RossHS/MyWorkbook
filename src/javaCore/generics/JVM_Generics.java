package javaCore.generics;

import javax.swing.*;
import java.util.ArrayList;
import java.util.Dictionary;
import java.util.Hashtable;

/**
 * Виртуальная машина и обобщения.
 * <p>
 * 1 Стирание типов. Всякий раз, когда определяется обобщенный тип, автоматически создается соответствующий ему базовый
 * (так называемый "сырой"/raw) тип. Имя этого типа совпадает с именем обобщенного типа с удаленными параметрами типа.
 * Переменные типа стираются и заменяются ограничивающими типами(или типом Object, если переменная не имеет ограничений).
 * Если отмечено 2 и более типов (extends Comparable & Serializable), то базовым будет Comparable, а компилятор
 * произведет приведение типов для Serializable, т.е. имеет смысл ставить маркерные интерфейсы в конце!
 * <p>
 * 2. Преобразование обобщенных выражений. Когда в программе вызывается обобщенный метод, компилятор вводит операции
 * приведения типов при стирании возвращаемого типа. Рассмотрим в качестве примера следующую последовательность
 * операторов:
 * Pair<Employee> buddies = . . .;
 * Employee buddy = buddies.getFirst();
 * В результате стирания из метода
 * getFirst () возвращается тип Object. Поэтому компилятор автоматически вводит приведение к типу Employee.
 * Это означает, что компилятор преобразует вызов данного метода в следующие две команды для виртуальной машины:
 * • вызвать метод базового типа Pair. getFirst ();
 * • привести тип Object возвращаемого объекта к типу Employee.
 * Операции приведения типов вводятся также при обращении к обобщенному полю.
 * Допустим, что поля first и second открытые, т.е. они объявлены как public. (Возможно, это и не самый лучший, но
 * вполне допустимый в Java стиль программирования.) Тогда при преобразовании приведенного ниже выражения в получаемый
 * в конечном итоге байт-код также будут введены операции приведения типов.
 * Employee buddy = buddies.first;
 * <p>
 * 3. Преобразование обобщенных методов. Стирание типов происходит и в обобщенных методах. Программисты обычно
 * воспринимают обобщенные методы как целое семейство методов вроде следующего:
 * public static <Т extends Comparable> Т min(T[] а)
 * Но после стирания типов остается только один приведенный ниже метод. Обратите внимание на то, что параметр
 * обобщенного типа Т стирается, а остается только ограничивающий тип Comparable,
 * public static Comparable min(Comparable[] a)
 * <p>
 * Таким образом, о преобразовании обобщений в Java нужно запомнить следующее.
 * • Для виртуальной машины обобщений не существует, но имеются только обычные классы и методы.
 * • Все параметры типа заменяются ограничивающими типами.
 * • Мостовые методы синтезируются для соблюдения принципа полиморфизма.
 * • Операции приведения типов вводятся по мере надобности для обеспечения типовой безопасности.
 * <p>
 * 4. Вызов унаследованного кода. Возможны две ситуации:
 * а. Когда мы передаем в метод обобщенный класс, где в качестве параметра указан обычный класс, компилятор выдаст
 * предупреждение.
 * б. Когда мы должны получить обобщенный объект от унаследованного кода. Его можно присвоить переменной обобщенного
 * типа, но тогда будет выдано предупреждение.
 * Итак, обратив внимание на предупреждение компилятора, можно воспользоваться аннотацией для того, чтобы оно исчезло.
 * Такую аннотацию следует разместить перед локальной переменной следующим образом:
 * @SuppressWarnings("unchecked")
 * Dictionary<Integer , Components> labelTable = slider.getLabelTable(); // без предупреждения
 * Аналогичным образом можно снабдить аннотацией весь метод, как показано ниже. Такая аннотация отменяет проверку
 * всего кода в теле метода.
 * SuppressWarnings("unchecked")
 * public void configureSlider() { . . . }
 *
 * @author Ross Khapilov
 * @version 1.0 created on 05.04.2018
 */
public class JVM_Generics<T> implements Cloneable {
    //1. Cтирание типов, В данном случае T не ограничена, она просто заменяется на Object
    T a;

    private T getA() {
        //здесь компилятор автоматически приведет тип из сырого в нужный
        return a;
    }

    public static void main(String[] args) {
        Dictionary<Integer,String>integerStringDictionary = new Hashtable<>();
        Example4 a = new Example4();
        a.set(integerStringDictionary);
        Dictionary<Integer,String>integerArrayListDictionary = a.getD();
    }
}

class Example4{
    Dictionary d;
    public void set(Dictionary dictionary){
        d = dictionary;
    }
    @SuppressWarnings("unchecked")
    public Dictionary getD() {
        return d;
    }
}
